#region System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e
// C:\Program Files\dotnet\shared\Microsoft.NETCore.App\8.0.20\System.Private.CoreLib.dll
#endregion

using System.Buffers;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Text;

namespace System
{
    public static class MemoryExtensions
    {
        public static Span<T> AsSpan<T>(this T[] array, int start);
        public static Span<T> AsSpan<T>(this T[] array, Index startIndex);
        public static Span<T> AsSpan<T>(this T[] array, Range range);
        public static ReadOnlySpan<char> AsSpan(this string text);
        public static ReadOnlySpan<char> AsSpan(this string text, int start);
        public static ReadOnlySpan<char> AsSpan(this string text, Index startIndex);
        public static ReadOnlySpan<char> AsSpan(this string text, Range range);
        public static ReadOnlySpan<char> AsSpan(this string text, int start, int length);
        public static ReadOnlyMemory<char> AsMemory(this string text);
        public static ReadOnlyMemory<char> AsMemory(this string text, int start);
        public static ReadOnlyMemory<char> AsMemory(this string text, Index startIndex);
        public static ReadOnlyMemory<char> AsMemory(this string text, int start, int length);
        public static ReadOnlyMemory<char> AsMemory(this string text, Range range);
        public static bool Contains<T>(this Span<T> span, T value) where T : IEquatable<T>;
        public static bool Contains<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>;
        public static bool ContainsAny<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>;
        public static bool ContainsAny<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>;
        public static bool ContainsAny<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>;
        public static bool ContainsAny<T>(this Span<T> span, SearchValues<T> values) where T : IEquatable<T>;
        public static bool ContainsAnyExcept<T>(this Span<T> span, T value) where T : IEquatable<T>;
        public static bool ContainsAnyExcept<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>;
        public static bool ContainsAnyExcept<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>;
        public static bool ContainsAnyExcept<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>;
        public static bool ContainsAnyExcept<T>(this Span<T> span, SearchValues<T> values) where T : IEquatable<T>;
        public static bool ContainsAnyInRange<T>(this Span<T> span, T lowInclusive, T highInclusive) where T : IComparable<T>;
        public static bool ContainsAnyExceptInRange<T>(this Span<T> span, T lowInclusive, T highInclusive) where T : IComparable<T>;
        public static bool ContainsAny<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>;
        public static bool ContainsAny<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>;
        public static bool ContainsAny<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>;
        public static bool ContainsAny<T>(this ReadOnlySpan<T> span, SearchValues<T> values) where T : IEquatable<T>;
        public static bool ContainsAnyExcept<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>;
        public static bool ContainsAnyExcept<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>;
        public static bool ContainsAnyExcept<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>;
        public static bool ContainsAnyExcept<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>;
        public static bool ContainsAnyExcept<T>(this ReadOnlySpan<T> span, SearchValues<T> values) where T : IEquatable<T>;
        public static bool ContainsAnyInRange<T>(this ReadOnlySpan<T> span, T lowInclusive, T highInclusive) where T : IComparable<T>;
        public static bool ContainsAnyExceptInRange<T>(this ReadOnlySpan<T> span, T lowInclusive, T highInclusive) where T : IComparable<T>;
        public static int IndexOf<T>(this Span<T> span, T value) where T : IEquatable<T>;
        public static int IndexOf<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>;
        public static int LastIndexOf<T>(this Span<T> span, T value) where T : IEquatable<T>;
        public static int LastIndexOf<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>;
        public static int IndexOfAnyExcept<T>(this Span<T> span, T value) where T : IEquatable<T>;
        public static int IndexOfAnyExcept<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>;
        public static int IndexOfAnyExcept<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>;
        public static int IndexOfAnyExcept<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>;
        public static int IndexOfAnyExcept<T>(this Span<T> span, SearchValues<T> values) where T : IEquatable<T>;
        public static int IndexOfAnyExcept<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>;
        public static int IndexOfAnyExcept<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>;
        public static int IndexOfAnyExcept<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>;
        public static int IndexOfAnyExcept<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>;
        public static int IndexOfAnyExcept<T>(this ReadOnlySpan<T> span, SearchValues<T> values) where T : IEquatable<T>;
        public static int LastIndexOfAnyExcept<T>(this Span<T> span, T value) where T : IEquatable<T>;
        public static int LastIndexOfAnyExcept<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>;
        public static int LastIndexOfAnyExcept<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>;
        public static int LastIndexOfAnyExcept<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>;
        public static int LastIndexOfAnyExcept<T>(this Span<T> span, SearchValues<T> values) where T : IEquatable<T>;
        public static int LastIndexOfAnyExcept<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>;
        public static int LastIndexOfAnyExcept<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>;
        public static int LastIndexOfAnyExcept<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>;
        public static int LastIndexOfAnyExcept<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>;
        public static int LastIndexOfAnyExcept<T>(this ReadOnlySpan<T> span, SearchValues<T> values) where T : IEquatable<T>;
        public static int IndexOfAnyInRange<T>(this Span<T> span, T lowInclusive, T highInclusive) where T : IComparable<T>;
        public static int IndexOfAnyInRange<T>(this ReadOnlySpan<T> span, T lowInclusive, T highInclusive) where T : IComparable<T>;
        public static int IndexOfAnyExceptInRange<T>(this Span<T> span, T lowInclusive, T highInclusive) where T : IComparable<T>;
        public static int IndexOfAnyExceptInRange<T>(this ReadOnlySpan<T> span, T lowInclusive, T highInclusive) where T : IComparable<T>;
        public static int LastIndexOfAnyInRange<T>(this Span<T> span, T lowInclusive, T highInclusive) where T : IComparable<T>;
        public static int LastIndexOfAnyInRange<T>(this ReadOnlySpan<T> span, T lowInclusive, T highInclusive) where T : IComparable<T>;
        public static int LastIndexOfAnyExceptInRange<T>(this Span<T> span, T lowInclusive, T highInclusive) where T : IComparable<T>;
        public static int LastIndexOfAnyExceptInRange<T>(this ReadOnlySpan<T> span, T lowInclusive, T highInclusive) where T : IComparable<T>;
        public static bool SequenceEqual<T>(this Span<T> span, ReadOnlySpan<T> other) where T : IEquatable<T>;
        public static int SequenceCompareTo<T>(this Span<T> span, ReadOnlySpan<T> other) where T : IComparable<T>;
        public static int IndexOf<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>;
        public static int IndexOf<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>;
        public static int LastIndexOf<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>;
        public static int LastIndexOf<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>;
        public static int IndexOfAny<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>;
        public static int IndexOfAny<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>;
        public static int IndexOfAny<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>;
        public static int IndexOfAny<T>(this Span<T> span, SearchValues<T> values) where T : IEquatable<T>;
        public static int IndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>;
        public static int IndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>;
        public static int IndexOfAny<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>;
        public static int IndexOfAny<T>(this ReadOnlySpan<T> span, SearchValues<T> values) where T : IEquatable<T>;
        public static int LastIndexOfAny<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>;
        public static int LastIndexOfAny<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>;
        public static int LastIndexOfAny<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>;
        public static int LastIndexOfAny<T>(this Span<T> span, SearchValues<T> values) where T : IEquatable<T>;
        public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>;
        public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>;
        public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>;
        public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, SearchValues<T> values) where T : IEquatable<T>;
        public static bool SequenceEqual<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other) where T : IEquatable<T>;
        public static bool SequenceEqual<T>(this Span<T> span, ReadOnlySpan<T> other, IEqualityComparer<T> comparer = null);
        public static bool SequenceEqual<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other, IEqualityComparer<T> comparer = null);
        public static int SequenceCompareTo<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other) where T : IComparable<T>;
        public static bool StartsWith<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>;
        public static bool StartsWith<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>;
        public static bool EndsWith<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>;
        public static bool EndsWith<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>;
        public static void Reverse<T>(this Span<T> span);
        public static Span<T> AsSpan<T>(this T[] array);
        public static Span<T> AsSpan<T>(this T[] array, int start, int length);
        public static Span<T> AsSpan<T>(this ArraySegment<T> segment);
        public static Span<T> AsSpan<T>(this ArraySegment<T> segment, int start);
        public static Span<T> AsSpan<T>(this ArraySegment<T> segment, Index startIndex);
        public static Span<T> AsSpan<T>(this ArraySegment<T> segment, int start, int length);
        public static Span<T> AsSpan<T>(this ArraySegment<T> segment, Range range);
        public static Memory<T> AsMemory<T>(this T[] array);
        public static Memory<T> AsMemory<T>(this T[] array, int start);
        public static Memory<T> AsMemory<T>(this T[] array, Index startIndex);
        public static Memory<T> AsMemory<T>(this T[] array, int start, int length);
        public static Memory<T> AsMemory<T>(this T[] array, Range range);
        public static Memory<T> AsMemory<T>(this ArraySegment<T> segment);
        public static Memory<T> AsMemory<T>(this ArraySegment<T> segment, int start);
        public static Memory<T> AsMemory<T>(this ArraySegment<T> segment, int start, int length);
        public static void CopyTo<T>(this T[] source, Span<T> destination);
        public static void CopyTo<T>(this T[] source, Memory<T> destination);
        public static bool Overlaps<T>(this Span<T> span, ReadOnlySpan<T> other);
        public static bool Overlaps<T>(this Span<T> span, ReadOnlySpan<T> other, out int elementOffset);
        public static bool Overlaps<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other);
        public static bool Overlaps<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other, out int elementOffset);
        public static int BinarySearch<T>(this Span<T> span, IComparable<T> comparable);
        public static int BinarySearch<T, TComparable>(this Span<T> span, TComparable comparable) where TComparable : IComparable<T>;
        public static int BinarySearch<T, TComparer>(this Span<T> span, T value, TComparer comparer) where TComparer : IComparer<T>;
        public static int BinarySearch<T>(this ReadOnlySpan<T> span, IComparable<T> comparable);
        public static int BinarySearch<T, TComparable>(this ReadOnlySpan<T> span, TComparable comparable) where TComparable : IComparable<T>;
        public static int BinarySearch<T, TComparer>(this ReadOnlySpan<T> span, T value, TComparer comparer) where TComparer : IComparer<T>;
        public static void Sort<T>(this Span<T> span);
        public static void Sort<T, TComparer>(this Span<T> span, TComparer comparer) where TComparer : IComparer<T>;
        public static void Sort<T>(this Span<T> span, Comparison<T> comparison);
        public static void Sort<TKey, TValue>(this Span<TKey> keys, Span<TValue> items);
        public static void Sort<TKey, TValue, TComparer>(this Span<TKey> keys, Span<TValue> items, TComparer comparer) where TComparer : IComparer<TKey>;
        public static void Sort<TKey, TValue>(this Span<TKey> keys, Span<TValue> items, Comparison<TKey> comparison);
        public static void Replace<T>(this Span<T> span, T oldValue, T newValue) where T : IEquatable<T>;
        public static void Replace<T>(this ReadOnlySpan<T> source, Span<T> destination, T oldValue, T newValue) where T : IEquatable<T>;
        public static int CommonPrefixLength<T>(this Span<T> span, ReadOnlySpan<T> other);
        public static int CommonPrefixLength<T>(this Span<T> span, ReadOnlySpan<T> other, IEqualityComparer<T> comparer);
        public static int CommonPrefixLength<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other);
        public static int CommonPrefixLength<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other, IEqualityComparer<T> comparer);
        public static int Split(this ReadOnlySpan<char> source, Span<Range> destination, char separator, StringSplitOptions options = StringSplitOptions.None);
        public static int Split(this ReadOnlySpan<char> source, Span<Range> destination, ReadOnlySpan<char> separator, StringSplitOptions options = StringSplitOptions.None);
        public static int SplitAny(this ReadOnlySpan<char> source, Span<Range> destination, ReadOnlySpan<char> separators, StringSplitOptions options = StringSplitOptions.None);
        public static int SplitAny(this ReadOnlySpan<char> source, Span<Range> destination, ReadOnlySpan<string> separators, StringSplitOptions options = StringSplitOptions.None);
        public static int Count<T>(this Span<T> span, T value) where T : IEquatable<T>;
        public static int Count<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>;
        public static int Count<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>;
        public static int Count<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>;
        public static bool TryWrite(this Span<char> destination, ref TryWriteInterpolatedStringHandler handler, out int charsWritten);
        public static bool TryWrite(this Span<char> destination, IFormatProvider provider, ref TryWriteInterpolatedStringHandler handler, out int charsWritten);
        public static bool TryWrite<TArg0>(this Span<char> destination, IFormatProvider provider, CompositeFormat format, out int charsWritten, TArg0 arg0);
        public static bool TryWrite<TArg0, TArg1>(this Span<char> destination, IFormatProvider provider, CompositeFormat format, out int charsWritten, TArg0 arg0, TArg1 arg1);
        public static bool TryWrite<TArg0, TArg1, TArg2>(this Span<char> destination, IFormatProvider provider, CompositeFormat format, out int charsWritten, TArg0 arg0, TArg1 arg1, TArg2 arg2);
        public static bool TryWrite(this Span<char> destination, IFormatProvider provider, CompositeFormat format, out int charsWritten, params object[] args);
        public static bool TryWrite(this Span<char> destination, IFormatProvider provider, CompositeFormat format, out int charsWritten, ReadOnlySpan<object> args);
        public static bool IsWhiteSpace(this ReadOnlySpan<char> span);
        public static bool Contains(this ReadOnlySpan<char> span, ReadOnlySpan<char> value, StringComparison comparisonType);
        public static bool Equals(this ReadOnlySpan<char> span, ReadOnlySpan<char> other, StringComparison comparisonType);
        public static int CompareTo(this ReadOnlySpan<char> span, ReadOnlySpan<char> other, StringComparison comparisonType);
        public static int IndexOf(this ReadOnlySpan<char> span, ReadOnlySpan<char> value, StringComparison comparisonType);
        public static int LastIndexOf(this ReadOnlySpan<char> span, ReadOnlySpan<char> value, StringComparison comparisonType);
        public static int ToLower(this ReadOnlySpan<char> source, Span<char> destination, CultureInfo culture);
        public static int ToLowerInvariant(this ReadOnlySpan<char> source, Span<char> destination);
        public static int ToUpper(this ReadOnlySpan<char> source, Span<char> destination, CultureInfo culture);
        public static int ToUpperInvariant(this ReadOnlySpan<char> source, Span<char> destination);
        public static bool EndsWith(this ReadOnlySpan<char> span, ReadOnlySpan<char> value, StringComparison comparisonType);
        public static bool StartsWith(this ReadOnlySpan<char> span, ReadOnlySpan<char> value, StringComparison comparisonType);
        public static SpanRuneEnumerator EnumerateRunes(this ReadOnlySpan<char> span);
        public static SpanRuneEnumerator EnumerateRunes(this Span<char> span);
        public static SpanLineEnumerator EnumerateLines(this ReadOnlySpan<char> span);
        public static SpanLineEnumerator EnumerateLines(this Span<char> span);
        public static Memory<T> Trim<T>(this Memory<T> memory, T trimElement) where T : IEquatable<T>;
        public static Memory<T> TrimStart<T>(this Memory<T> memory, T trimElement) where T : IEquatable<T>;
        public static Memory<T> TrimEnd<T>(this Memory<T> memory, T trimElement) where T : IEquatable<T>;
        public static ReadOnlyMemory<T> Trim<T>(this ReadOnlyMemory<T> memory, T trimElement) where T : IEquatable<T>;
        public static ReadOnlyMemory<T> TrimStart<T>(this ReadOnlyMemory<T> memory, T trimElement) where T : IEquatable<T>;
        public static ReadOnlyMemory<T> TrimEnd<T>(this ReadOnlyMemory<T> memory, T trimElement) where T : IEquatable<T>;
        public static Span<T> Trim<T>(this Span<T> span, T trimElement) where T : IEquatable<T>;
        public static Span<T> TrimStart<T>(this Span<T> span, T trimElement) where T : IEquatable<T>;
        public static Span<T> TrimEnd<T>(this Span<T> span, T trimElement) where T : IEquatable<T>;
        public static ReadOnlySpan<T> Trim<T>(this ReadOnlySpan<T> span, T trimElement) where T : IEquatable<T>;
        public static ReadOnlySpan<T> TrimStart<T>(this ReadOnlySpan<T> span, T trimElement) where T : IEquatable<T>;
        public static ReadOnlySpan<T> TrimEnd<T>(this ReadOnlySpan<T> span, T trimElement) where T : IEquatable<T>;
        public static Memory<T> Trim<T>(this Memory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>;
        public static Memory<T> TrimStart<T>(this Memory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>;
        public static Memory<T> TrimEnd<T>(this Memory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>;
        public static ReadOnlyMemory<T> Trim<T>(this ReadOnlyMemory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>;
        public static ReadOnlyMemory<T> TrimStart<T>(this ReadOnlyMemory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>;
        public static ReadOnlyMemory<T> TrimEnd<T>(this ReadOnlyMemory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>;
        public static Span<T> Trim<T>(this Span<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>;
        public static Span<T> TrimStart<T>(this Span<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>;
        public static Span<T> TrimEnd<T>(this Span<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>;
        public static ReadOnlySpan<T> Trim<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>;
        public static ReadOnlySpan<T> TrimStart<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>;
        public static ReadOnlySpan<T> TrimEnd<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>;
        public static Memory<char> Trim(this Memory<char> memory);
        public static Memory<char> TrimStart(this Memory<char> memory);
        public static Memory<char> TrimEnd(this Memory<char> memory);
        public static ReadOnlyMemory<char> Trim(this ReadOnlyMemory<char> memory);
        public static ReadOnlyMemory<char> TrimStart(this ReadOnlyMemory<char> memory);
        public static ReadOnlyMemory<char> TrimEnd(this ReadOnlyMemory<char> memory);
        public static ReadOnlySpan<char> Trim(this ReadOnlySpan<char> span);
        public static ReadOnlySpan<char> TrimStart(this ReadOnlySpan<char> span);
        public static ReadOnlySpan<char> TrimEnd(this ReadOnlySpan<char> span);
        public static ReadOnlySpan<char> Trim(this ReadOnlySpan<char> span, char trimChar);
        public static ReadOnlySpan<char> TrimStart(this ReadOnlySpan<char> span, char trimChar);
        public static ReadOnlySpan<char> TrimEnd(this ReadOnlySpan<char> span, char trimChar);
        public static ReadOnlySpan<char> Trim(this ReadOnlySpan<char> span, ReadOnlySpan<char> trimChars);
        public static ReadOnlySpan<char> TrimStart(this ReadOnlySpan<char> span, ReadOnlySpan<char> trimChars);
        public static ReadOnlySpan<char> TrimEnd(this ReadOnlySpan<char> span, ReadOnlySpan<char> trimChars);
        public static Span<char> Trim(this Span<char> span);
        public static Span<char> TrimStart(this Span<char> span);
        public static Span<char> TrimEnd(this Span<char> span);

        [EditorBrowsable(EditorBrowsableState.Never)]
        [Obsolete("Types with embedded references are not supported in this version of your compiler.", True)]
        public ref struct TryWriteInterpolatedStringHandler
        {
            public TryWriteInterpolatedStringHandler(int literalLength, int formattedCount, Span<char> destination, out bool shouldAppend);
            public TryWriteInterpolatedStringHandler(int literalLength, int formattedCount, Span<char> destination, IFormatProvider provider, out bool shouldAppend);

            public bool AppendLiteral(string value);
            public bool AppendFormatted<T>(T value);
            public bool AppendFormatted<T>(T value, string format);
            public bool AppendFormatted<T>(T value, int alignment);
            public bool AppendFormatted<T>(T value, int alignment, string format);
            public bool AppendFormatted(scoped ReadOnlySpan<char> value);
            public bool AppendFormatted(scoped ReadOnlySpan<char> value, int alignment = 0, string format = null);
            public bool AppendFormatted(string value);
            public bool AppendFormatted(string value, int alignment = 0, string format = null);
            public bool AppendFormatted(object value, int alignment = 0, string format = null);
        }
    }
}
